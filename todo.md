[x] url 的正则，包括 hash、query、port、host、protocol、path
[x] 跨域、options 请求
[ ] url 到页面
[x] http 缓存
[x] tcp\udp
[x] http1~3、https
[x] bfc
[ ] 层叠上下文
[x] react 的 key
[x] 根据 key 的 diff 算法
[x] fiber、workloop
[x] promise 的实现 & 应用
[x] babel 了解
[x] 二叉树非递归前中后遍历
[ ] 二叉树前中后遍历互相转化
[x] event loop(node、浏览器、node11+)
[ ] 海盗分金币
[x] 大文件上传、断点续传
[ ] setstate、usestate、usecallback 实现
[ ] 原形链、多种继承
[ ] redux、react-redux、中间件
[ ] compose
[ ] redux-saga、generator
[ ] proxy 深拷贝、immer
[ ] 从旧版 react 的 class 组件那套到现在
[ ] 灰度发布
[ ] node 挂掉怎么办、pm2、死循环捕获
[ ] koa 中间件、redux 中间件
[ ] webpack plugin、tapable
[ ] dll plugin
[ ] sw、pwa
[ ] 性能监控、错误监控
[ ] ci、cd
[x] cssom 如何寻找 dom 生成 render 树的
[x] https 原理、ca、数字证书、信任链
[x] websocket 握手
[ ] webpack hmr 原理
[x] babel 原理、运行过程、polyfill 实现
[ ] webpack 优化打包策略、内部机制、插件开发原理
[ ] 如何提升 node 的稳定性
[x] cjs 原理
[ ] webpack 的 watch 机制
[ ] websocket 和 tcp socket 区别，ws 握手过程，为什么要基于 http 握手
[ ] 微信小程序架构
[ ] 两三列布局
[ ] 单行多行文本溢出省略
[ ] 圣杯、双飞翼布局
[ ] 固定宽高比

# 字节跳动

## 1

1. 项目难点
2. 如何设计权限系统，如何维护和定义、表的数据结构是怎样的
3. 中间人劫持，怎么防止。x-frame-option?白屏的喔，怎么办？也不一定嵌入 iframe 啊，可以嵌入脚本、图片，怎么阻止
4. class 组件和 function 组件对比。写过安卓吗，那对 class 组件有什么看法
5. hook 缺点，hook 代码难维护怎么解决(最难题目，被虐了一波，没有超大项目的实践是想象不出的)
6. redux 为什么每次 reducer 要返回一个新对象，面对大量节点如何优化
7. immuatable 和 shouldupdate 配合、immuatable 数据一些对比问题
8. http 缓存、离线包原理、移动端首屏幕加载速度优化、webview 冷启动、预热
9. 一个很牛逼很多功能的 class 组件，里面有业务生命周期，怎么在函数组件里面直接复用它
10. 给定一个整数数组 a，其中 1 ≤ a[i] ≤ n （n 为数组长度）, 其中有些元素出现两次而其他元素出现一次。
    找到所有出现两次的元素。
    你可以不用到任何额外空间并在 O(n)时间复杂度内解决这个问题吗？(限时 5 分钟)

输入:
[4,3,2,7,8,2,3,1]
输出:
[2,3]
A

## 2

1. cdn 原理
2. 为什么多域名部署
3. 单元测试、e2e 测试
4. event loop
5. 项目介绍一下
6. 客户端 mock 怎么支持
7. 怎么 mock 真数据，我需要真的 id 怎么办，除了写死
8. 什么情况用 ts、什么时候不用
9. 单元测试和 ts 结合
10. 全球远程调度机器实现自动化测试
11. cjs 实现 esm

## 3

1. 项目介绍。权限系统业界内怎么设计，常见的几种
2. 工作量体现到什么地方，现在工作量大吗
3. 最困难的环节
4. 优点缺点、未来规划
5. 怕被人挑战吗，怎么应对

## hr 后加面

1. 经过前面对了解，你知道我们这边做什么了吗，描述一下
2. 我们的技术栈差不多，如果你来上班，如何快速过渡和上手适应
3. 对 b 和 c 端业务对理解
4. tob 业务架构设计、技术选型
5. 项目开发流程、生命周期
6. 自动化测试设计思路

# 拼多多

## 1

1. react16 新生命周期，有什么变化
2. react16 之前的那些不好的生命周期怎么过度到 react16 的新生命周期
3. widllrecieveprops 用到了 this，getDriverStateFromProps 也要用，怎么办
4. 编程题：['aaafsd', 'aawwewer', 'aaddfff'] => 'aa'(无调试，靠想象)
5. 编程题：['aa/bb/sd', 'aa/bb/wwewer', 'aa/bb/ddfff'] => 'aa/bb'(无调试，靠想象)
6. 怎么理解 ts
7. ts 的 type 和 interface 什么区别
8. ssr 怎么实现，你们怎么做
9. 你们有没有统一构建的 cli，怎么实现
10. 你们项目有 ci 吗，怎么做，提交的时候会做什么事情
11. e2e 测试、自动化测试
12. git rebase 什么作用

## 2

1. 项目介绍
2. 项目难点
3. 实现一个 redux
4. 如果是用 ts 写，怎么写

# 猿辅导

## 1

1. react 生命周期介绍，怎么执行。说一下下面的组件生命周期执行顺序
   `<A> <B /> </A>`
   a.willMount 3
   b.willMount 1
   a.didMount 4
   b.didMount 2
2. redux vs context，为什么不用 context
3. react 17 要做什么规划，concurrent mode
4. SSR，打开你们的 SSR 页面看看，具体逻辑、实现方式
5. promise.then(f1, f2)和 promise.then(f1).catch(f2)区别
6. () => {} vs function () {}
7.

```js
const obj = {‏‎ ‎
  f1:‏‎ ‎() => console.log(this),
  f2‏‎ ‎() { console.log(this) },
};
obj.f1() // global
obj.f2() // obj
new obj.f1; // instance
new obj.f2; // instance
```

8. Map/Set、WeakMap，什么作用
9. 用 setTimeout 实现 setInterval
10. Node { value: number; children: Node[] }，算出树每一层节点和，输出数组

```
         2         => 2
  2      3      5  => 10
1   2  3   4   7 8 => 25
// 每一层的和 [2, 10, 25]；
```

## 2

1. 节流、和防抖的区别，均匀的节流怎么实现
2. http 缓存、强制缓存里面 expire 和 cache-control 作用，什么坑
3. 前端路由实现。history 什么坑，怎么解决
4. var、let、const 区别，() => {} vs function () {}
5. 一副扑克牌，随机抽 5 张，判断是否是顺子，大小王可以替代任意牌。
   ['A', '2', '3', 'S', 'B'] true
6. ES5 实现 B 继承 A

## 3

1. 项目难点，画一下架构
2. 有了解其他权限系统吗，对比下
3. http 请求的整个过程
4. 怎么知道一个 tcp 请求数据已经完了呢
5. 微博的@的下面出现一个提示怎么实现。不是 editable 喔，基于 textarea 怎么实现
6. 怎么知道服务端请求回来后，客户端是局域网下哪一个 ip
7. 为什么是 tcp 而不是 udp。tcp 丢包怎么办，怎么知道丢包，怎么知道已经重传成功了
8. 了解 http3 的 quic 吗
9. quic 怎么解决了 tcp 的问题
10. quic 用 udp 怎么保证了可靠性
11. quic 的 udp 如果不握手，人家随便发请求怎么办
12. 函数式编程、纯函数
13. 状态管理系统设计，怎么和函数式编程结合
14. rxjs 介绍一下
15. 数组和链表的区别
16. 数组和链表优点缺点，应用场景

# 虾皮

## 1

1. 项目突出点，挖项目细节问题
2. 各种情况下的**proto**指向，多道问答题
3. 页面 10 张 img，http1 是怎样的加载表现，怎么解决。那多域名又为什么可以解决呢
4. http 缓存是怎样的。etag 和 last modify 分别什么优点缺点，适合什么场景
5. 接上题，10 张 img，http2 是怎样表现
6. http2 为什么快，多了什么特性，头部压缩算法是怎样
7. react 性能优化
8. 长列表优化，多种方案及对比
9. diff 算法、key 作用，不要 key 会怎样
10. react 的 usememo 原理
11. 编程题：对象扁平化

## 2

1. 项目相关，细问
2. 如果我接入你做的平台，怎么接入
3. jsbridge 了解么，说一下
4. addeventlistener 第三个参数作用
5. commondjs 和 esm 区别
6. 为什么浏览器不用 commondjs 而用了 esm
7. es6 了解不，说一下 let、const 的暂时性死区
8. set、map 有什么好处，map 和一般的对象有什么不一样
9. 跨端的方案
10. 编程题： 大数相乘

# 作业帮

## 1

1. 一堆看代码说输出的题
2. 项目介绍
3. cache-loader 有什么坑，缓存错误怎么解决
4. 编程题，9 选 3，不过我全部都做了，平均一分钟一道题
   bind、防抖&节流、settimeout 实现 interval、字符串大小写反转、节点是不是属于某个节点树下、三道数组题、一堆数字字符串组成最大数是多少

## 2

1. 说项目，深挖
2. react 生命周期和 diff 算法
3. key 的作用

# 商汤科技

## 1

1. 看见你写的文章，还很深的，说一下这几篇
2. react 的 class 组件和函数组件有什么不同
3. class 组件存在问题，函数组件的问题
4. class 组件和函数组件 diff、渲染、挂载过程差异
5. em、px、rem
6. rxjs 在复杂异步管理的作用
7. websocket 和 http 协议区别
8. 完全不同的域名共享 localstorage 的方案
9. 如果 react 项目要接入 redux，每一步要怎么做
10. 对象、引用类型、immutable、...、Object.assign

## 2

1. 项目深挖，反问一些问题
2. settimeout(a, 3000); ...同步代码执行很久 settimeout(b, 1000)多少种情况，临界值
3. 为什么会这样，说一下 event loop
4. 浏览器底层对线程冲突的实现
5. 一个页面，有图片、文字等各种内容，要求不能打乱排版和比例，如何兼容所有端
6. 浏览器缓存在 spa 的应用。html 要不要缓存，为什么？其他资源呢，为什么
7. react 性能优化
8. 100 条香蕉，猴子离家 50 米，猴子每走一米要吃一根香蕉，猴子最大负重是 50 条香蕉。问猴子怎么做，可以做到拿回家香蕉最大化，最大可以拿到多少条回家

## 3

1. 项目深挖、提问
2. 你项目怎么接入 ci 的，整个流水线是怎样
3. 设计一个短链接系统

## 1

1. 看见你写的文章，还很深的，说一下这几篇【描述】
   挺 surprise 的，居然有人那么用心看我文章，还看细节。于是带着兴奋的心情迫不及待和他介绍了
2. react 的 class 组件和函数组件有什么不同【描述】
   class 组件有生命周期有状态、函数组件就看返回值无状态(现在有 hook 了)
3. class 组件存在问题，函数组件的问题【举例】
   又是经典问题，class 组件随着项目变大生命周期逻辑过于耦合、庞大，函数组件可以更细粒。class 组件需要走实例化流程，但可以使用装饰器。函数组件就不能使用装饰器了，函数组件 ref 需要 forwardRef，不用纠结 this。如果代码量都很多，函数组件可读性高一些
4. class 组件和函数组件 diff、渲染、挂载过程差异【描述】
   其实是一样的，最终结果有点不一样，可以看打包后代码
5. em、px、rem【描述】
6. rxjs 在复杂异步管理的作用【举例】
   没有在项目用过，他们那边是挺需要 rxjs 这种异步管理的，把流程视为时间轴，使用管道操作符操作异步数据流。一切异步流程你都可以画在弹珠图上清晰看见
7. websocket 和 http 协议区别【描述】
   http 无状态、被动；ws 一次握手，知道状态，可以双向通信
8. 完全不同的域名共享 localstorage 的方案【描述】
   公共服务器双工通信(比较简单暴力)、嵌套 iframe 并双向通信(只要一个变了，马上通知另一方，保证他们的 localstorage 一模一样)
9. 如果 react 项目要接入 redux，每一步要怎么做【举例】
   从 api 的使用到源码的实现。源码流程：provider 传入 store，connect 要 return 一个组件，使用 mapstatetoprops 和 mapdispatchtoprops 扩展 props，然后 subscribe 一下 store，每次变化更新组件
10. 对象、引用类型、immutable、...、Object.assign【描述】
    放松一下，我们聊些简单的......
11. 写一个你熟悉的吧，antd 的 tree 渲染这个数据结构【伪代码】
    在面试的页面上直接写 jsx，高亮看得难受，也没代码提示。真的是放松题了，一个递归，tree 包一下 treenode，完事

一面还是挺轻松的，一种和人家交流技术的感觉。后面聊了很久他们的业务，做 ai 编程的，提交程序放到一个平台上跑，全程 websocket 双向通信，此时页面上有各种程序和图表，各种异步混杂起来，大概可以理解为什么用 rxjs 了

## 2

1. 项目深挖，反问一些问题【描述】
2. settimeout(a, 3000); ...同步代码执行很久 settimeout(b, 1000)多少种情况，临界值【描述】【举例】
   同步代码执行时间 <= 3000，顺序。 > 3000 先 b 再 a
3. 为什么会这样，说一下 event loop【描述】
   背书
4. 浏览器底层对线程冲突的实现【描述】
   不知道了。对方说因为有一个 watcher，你可以看一下 Chrome 底层实现，比死记硬背宏任务微任务更好
5. 一个页面，有图片、文字等各种内容，要求不能打乱排版和比例，如何兼容所有端【举例】
   rem 方案。但还是要看情况，一般情况下，手机是竖着的，电脑是横着的，总要对其中一个补白，不然很难看
6. 浏览器缓存在 spa 的应用。html 要不要缓存，为什么？其他资源呢，为什么【举例】
   html 不缓存，都是引用 js，要保证最新。其他可以缓存，每次发布文件名都有哈希、md5 保证不一样，而且也是增量部署的
7. react 性能优化【举例】
   又是老问题了。scu 生命周期、memo；usememo & usecallback 记住一些值不用重新计算；虚拟列表；immutable+scu/memo；原生 js；
8. 100 条香蕉，猴子离家 50 米，猴子每走一米要吃一根香蕉，猴子最大负重是 50 条香蕉。问猴子怎么做，可以做到拿回家香蕉最大化，最大可以拿到多少条回家【伪代码】
   结果是啥不重要了，主要是思路。他问用 dp 还是贪心，我说都行吧，dp 肯定是可以，贪心也算得上是。写了一段伪代码，在离家 n 米处有 s 条香蕉，每次选择回头或者前进，回头的话会损失 2 \* (50 - n) + 1，并补全到 50 条(库存能支持的情况下，相当于新增量减去损失量);选择前进，只会减少 1。每一步选择最多剩余的，等于下一步的 s 值。临界点：离家 0 米，s 就是答案; 离家 50 米，s 就是 50

## 3

1. 项目深挖、提问【描述】
2. 你项目怎么接入 ci 的，整个流水线是怎样【描述】
   git 提交 => lint 执行 => 触发 hook => 读取 yml 文件执行命令 => 部署 => 调用机器人接口发布企业微信群周知
3. 设计一个短链接系统【描述】
   页面链接映射 => 时间戳 + 关键字符串 => 映射到数字序号转高进制 => 获得短链接

1) 分析一个项目的依赖结构，并按依赖优先级排序。
   已知一个项目的依赖结构，期望在前端通过 loader 的方式异步加载相关的组件，而我们期望依赖在加载的过程中：

每一个依赖被加载后都会被立刻执行，那么如果要争取加载一个依赖，则其子依赖都应该优先被加载
每一个依赖不希望多出现冗余的情况，若依赖出现多版本的情况，则默认使用更新的版本，比如已知项目依赖结构为（其中 @ 后面的为依赖版本号）：

```
ProjectA
- a@0.1.0
    - d@0.2.0
    - c@0.1.0
- b@0.1.1
    - e@0.1.2
    - c@0.1.2
- c@0.2.0
```

复制代码则其中一种输出的依赖优先级排序为：
['d@0.2.0', 'c@0.2.0', 'a@0.1.0', 'e@0.1.2', 'b@0.1.1']
输出分析：
为了让 a 加载后可以争取执行，则必须先加载 d 和 c，b 的加载同理，又因为在整个依赖关系下，c 的最新版本为 0.2.0 于是有了如上的输出结果。

2. 实现一个请求缓存的函数，希望输入同样的请求 url 返回同样的结果，不发请求，达到优化的目的。只需考虑 get 请求。比如 request('/a')，第二次以后再遇到'/a'则不发请求，取之前的结果。

3. 对象扁平化： { a: { b: c: { d:1 } }, e: [1, 10] } => { 'a.b.c.d': 1, 'e[0]': 1, 'e[1]': 10 }，将一个嵌套的对象转成一个扁平化的对象，旧对象所有的深层递归的值都会转为.或者[]的路径作为新对象的 key

4. { 'a.b.c.d': 1, 'e[0]': 1, 'e[1]': 10 } => { a: { b: c: { d:1 } }, e: [1, 10] }。和上相反，将一个扁平化对象转为一个层层嵌套的对象

5. 经典的 lazyman 问题

6. Combo
   url 页面 page 的主函数入口在 page.js，以下为其依赖树。为了性能要求，我们页面会组装一个 combo 请求：
   http://res.wx.qq.com/F.js,E.js,D.js,C.js,B.js,A.js,page.js请设计genUrl(requireTree)，输出如上所示的combo url。

requireTree 的数据结构如下

```
requireTree =  {
  "name" : "page.js",
  "require" : [
    {
      "name":"A.js",
      "require": [{
        "name": "C.js",
        "require": [{
          "name":"F.js"
          }]
        }]
      },
      {
        "name":"B.js",
        "require": [{
          "name":"D.js",
          "require": [{
            "name":"F.js"
          }]
        },
        {
          "name":"E.js",
          "require" : []
        }
      ]
    }
  ]
}

```

# 对象扁平化

将一个嵌套的对象转成一个扁平化的对象，旧对象所有的深层递归的值都会转为.或者[]的路径作为新对象的 key

```js
{ a: { b: c: { d:1 } }, e: [1, 10] } => { 'a.b.c.d': 1, 'e[0]': 1, 'e[1]': 10 }
```

常见的场景：树形结构，节点带 id。每一个节点都有交互，所以看起来其实是和扁平没有区别。用的时候，id 即是每层节点值的拼接

## 一层的情况

## 多层的情况，只考虑普通对象

## 考虑数组

## 代码优化

# 还原扁平化对象

和上相反，将一个扁平化对象转为一个层层嵌套的对象

```js
{ 'a.b.c.d': 1, 'e[0]': 1, 'e[1]': 10 } => { a: { b: c: { d:1 } }, e: [1, 10] }
```

有转换扁平，那么也有还原。我们看看，输入对象是扁平的，所以不存在递归。显然这是实现一个对象每一对 key-value 进行 lodash.set 操作

## 使用 split，麻烦

## 使用正则，几乎不用思考

## 多层级的对象初始值确定

## 多层级循环赋值

# 实现一个请求缓存的函数

希望输入同样的请求 url 返回同样的结果，不发请求，达到优化的目的。只需考虑 get 请求。比如 request('/a')，第二次以后再遇到'/a'则不发请求，取之前的结果

当你页面上有一个接口，经常不变的，你可以使用这种方式。比如 select 的下拉选项的获取、配置数据、切换页面又切回来等。只需要请求一次，后面就继续复用

## 理想状态

请求 => 缓存 => 再次有同样的请求直接读取

## 会有什么问题

## 一个请求发出去还没响应，又发了一个一样的

希望第二个不要发请求了，等第一个

## 订阅请求返回

# 输出目录加载结果

每一个依赖被加载后都会被立刻执行，那么如果要争取加载一个依赖，则其子依赖都应该优先被加载
每一个依赖不希望多出现冗余的情况，若依赖出现多版本的情况，则默认使用更新的版本。我们可以从这里来了解一下类似平时 node 加载依赖的过程

```
- a@0.1.0
    - d@0.2.0
    - c@0.1.0
- b@0.1.1
    - e@0.1.2
    - c@0.1.2
- c@0.2.0

```

则其中一种输出的依赖优先级排序为：
['d@0.2.0', 'c@0.2.0', 'a@0.1.0', 'e@0.1.2', 'b@0.1.1’]

## 加载一个依赖，则其子依赖都应该优先被加载

递归实现

## 每一个依赖不希望多出现冗余的情况

### 对比版本

### map 缓存

### 为什么用 map
